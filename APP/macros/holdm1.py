import win32api
import win32con
import time
import threading
from keyboard import press_and_release

class M1Listener:
    def __init__(self):
        self.running = True
        self.thread = None

    def is_mouse_swapped(self):
        return win32api.GetSystemMetrics(23) != 0

    def get_primary_button(self):
        if self.is_mouse_swapped():
            return "right"
        return "left"

    def simulate_click(self, key):
        #x, y = win32api.GetCursorPos()
        press_and_release(key)
        #if self.get_primary_button() == "right":
            #win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTDOWN, x, y, 0, 0)
        #else:
            #win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, x, y, 0, 0)

    def check_button_state(self, vk_code):
        state = win32api.GetAsyncKeyState(vk_code)
        return (state & 0x8000) != 0

    def macro_thread(self, key):
        hold_start = 0
        is_auto_clicking = False
        
        while self.running:
            try:
                # Check both buttons
                left_pressed = self.check_button_state(win32con.VK_LBUTTON)
                right_pressed = self.check_button_state(win32con.VK_RBUTTON)
                
                # Determine if the primary button is pressed
                primary_pressed = right_pressed if self.is_mouse_swapped() else left_pressed
                
                # Button just pressed
                if primary_pressed and hold_start == 0:
                    hold_start = time.time()
                
                # Button being held
                elif primary_pressed and hold_start > 0:
                    hold_duration = time.time() - hold_start
                    
                    # Check for auto-click threshold
                    if hold_duration >= 0.2:
                        if not is_auto_clicking:
                            is_auto_clicking = True
                        self.simulate_click(key)
                        time.sleep(0.04)
                
                # Button released
                elif not primary_pressed and hold_start > 0:
                    hold_start = 0
                    is_auto_clicking = False
                
                time.sleep(0.001)  # Prevent CPU overload
                
            except KeyboardInterrupt:
                print("\nStopping...")
                break

    def run(self, key='`'):
        print('checking')
        """Start the macro thread"""
        if not self.thread or not self.thread.is_alive():
            print('starting!!')
            self.running = True
            self.thread = threading.Thread(target=self.macro_thread, args=key)
            self.thread.daemon = True
            self.thread.start()

    def stop(self):
        """Stop the macro thread"""
        self.running = False
        if self.thread and self.thread.is_alive():
            self.thread.join(timeout=1.0)  # Wait up to 1 second for the thread to stop
            if self.thread.is_alive():
                print("Warning: Thread did not stop cleanly")

def main():
    controller = M1Listener()
    controller.start()
    
    try:
        # Keep the main thread alive
        while True:
            time.sleep(0.1)
    except KeyboardInterrupt:
        print("\nExiting program...")
        controller.stop()

if __name__ == "__main__":
    main()
